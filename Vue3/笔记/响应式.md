#### 响应式系统
* 响应式系统最核心的方法是`reactive()`
  * 接收一个复杂类型的对象返回一个响应式的代理对象
  * 对于操作代理对象的getter和setter方法都会产生副作用，引起视图变化
  * 缺点是无法进行对象解构——解构之后会失去响应性，ref解决了这个问题
* 对于`ref()`函数可以监听简单数据类型和复杂数据类型
  * 通过`.value`的形式进行调用
  * `ref()`函数接收一个数据并返回一个`RefImpl`实例对象
    * 对于复杂数据类型的值直接调用`reactive()`返回`proxy`进行依赖收集和依赖触发
    * 对于简单数据类型的值直接返回
    * 同时`Vue`实现了get value() 和set value()属性函数，通过主动触发这两个属性函数来完成来完成对数据收集和依赖触发
  * 对于数据进行`getter`或者`setter`行为时引发的一系列操作，如：引起视图改变

* `proxy`-代理对象；`Reflect`-代理js操作——可以改变操作的`this`值

* `Vue2` vs `Vue3` 对一个对象属性的新增行为，因此无法使用`Object.defineProperty`监听新增属性的`getter`和`setter`行为。因此，对于新增的对象属性或者通过数组下标新增的值会失去响应性
  * `Vue3`改进了这种不足，使用`proxy`对象代理的方式实现对对象属性的监听


* `computed` vs `watch`
  * 计算属性被基于其响应式依赖被缓存并在依赖的响应式数据发生变化时重新计算