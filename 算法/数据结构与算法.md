#### 数据结构与算法

**重点关注**：数据结构与算法的特点、应用场景、JS实现、时间/空间复杂度

* 时间复杂度：

  一个函数，用来衡量代码的执行时间大小

  ![image-20240625161345805](C:\Users\ccwangxin\AppData\Roaming\Typora\typora-user-images\image-20240625161345805.png)

* 空间复杂度

  一个函数，用来衡量代码在运行过程中临时占用存储空间的大小

##### 数据结构

计算机存储、组织数据的方式

程序 = 数据结构 + 算法

数据结构为算法提供服务，算法围绕数据结构操作

* 栈

  * 应用场景——所有需要**后进先出**的场景
    * 十进制转二进制、判断字符串的括号是否有效、**函数调用堆栈**
  * Js中没有栈，但可以用Array实现栈的所有功能
  * 栈常用操作：`push`、`pop`、`stack[stack.length - 1]`

* 队列

  * 应用场景——所有需要**先进先出**的场景

    * 食堂排队打饭、**JS异步中的任务队列**、计算最近请求次数

    ![image-20240625174307770](C:\Users\ccwangxin\AppData\Roaming\Typora\typora-user-images\image-20240625174307770.png)

    * 事件循环与任务队列

      当程序开始执行时，会有一个匿名函数被放到消息队列中，JS引擎从消息队列中取到此匿名函数进行执行，JS是单线程的，在执行过程中遇到异步任务则交给web API进行执行，并将执行之后的回调函数放入消息队列中，等待下次事件循环时从消息队列中取出一个函数继续执行，直到消息队列为空则执行完毕。

* 链表

  * 多个元素组成的列表
  * 元素存储不连续，用next指针连在一起
  * 数组 vs 链表
    * 数组增删非首尾元素时往往需要移动元素
    * 链表增删非首尾元素时，不需要移动元素只需要修改next指针即可
  * 删除链表中元素（非尾元素）
    * 不直接删除当前元素
    * 通过将当前元素的next指向的元素值赋值给当前元素删除下一个元素
  * 反转链表
    * 两个指针遍历链表
  * 判断指针是否有环
    * 一快一慢两个指针是否相遇
  * **原型链**
    * `A instanceof B`——判断A的原型链上能否找到构造器B的原型对象
    * 实现：遍历链表
  * **使用链表指针可以获取JSON的节点值**

* 集合

  * 一种**无序且唯一**的数据结构
  * 可以求两个集合的交集
  * 使用Set对象：new、add、delete、has、size
  * 迭代Set：多种迭代方法、Set与Array互转、求交集/差集

* 字典

  * 与集合类似，字典也是一种存储唯一值的数据结构，并且以键值对的形式来存储
  * 与JavaScript中的Map对应
  * set、delete、clear、get

* 树

  * 一种分层数据的抽象类型
  * 应用场景：DOM树、级联选择、树形控件
  * 深度优先遍历（dfs）
    * 访问根节点
    * 对根节点的children挨个进行深度优先遍历（递归）
  * 广度优先遍历（bfs）
    * 创建一个队列并将根节点入队
    * 队首元素出队并遍历
    * 将出队元素的children以此入队
    * 重复二三步骤直到队列为空
  * 二叉树
    * 先序遍历
      * 遍历根节点
      * 对根节点的左子树进行先序遍历
      * 对根节点的右子树进行先序遍历
    * 中序遍历
      * 对根节点的左子树进行中序遍历
      * 遍历根节点
      * 对根节点的右子树进行中序遍历
    * 后序遍历
      * 对根节点的左子树进行后序遍历
      * 对根节点的右子树进行后序遍历
      * 遍历根节点

* 图

  * 图是网络结构的抽象模型，是一组由边连接的节点
  * 图可以表示任何二元关系，比如道路、航班....
  * JS中没有图，可以用`object`或`Array`来表示图结构
  * 图的表示法
    * 邻接矩阵
    * 邻接表
  * 图的常用操作
    * 深度优先遍历
      * 访问根节点
      * 对根节点的未访问过的邻接节点以此进行深度优先遍历
    * 广度优先遍历
      * 新建一个队列，将根节点入队
      * 将对头元素出队
      * 将对头的未访问过的临界节点入队
      * 重复二三步骤

* 堆

  * 一种特殊的完全二叉树

  * 所有的节点都大于等于或者小于等于它的子节点

  * JS中通常用数组表示堆

    * 左侧子节点的位置是`2*index + 1`
    * 右侧子节点的位置是`2*index + 2`
    * 父节点位置是`(index - 1)/2`

  * 应用场景

    * 高效快速找出最大值和最小值`O(1)`

    * 求第K大的元素、求第K小的元素

##### 排序和搜索算法

* sort
* indexOf

##### 进阶算法

* 冒泡排序

  * 比较相邻元素，满足条件交换

  * 每一轮排序后都有一个最大/最小值位于正确的位置上
  * 时间复杂度（O(n^2)）

* 选择排序

  * 每一轮选择当前元素的最小元素下标与最前面的元素进行交换
  * 每一轮过后最前面的元素整个数组的最小值
  * 时间复杂度`O(n^2)`

* 插入排序

  * 从第二个数开始往前比
  * 比它的就往后排
  * 以此类推进行到最后一个数
  * 时间复杂度`O(n^2)`

* 归并排序

  * 时间复杂度：`O(nlogn)`
  * 火狐浏览器的排序算法——归并排序
  * 思路：
    * 分：把数组劈成两半，在递归地堆子数组进行“分”操作，直到分成一个个单独的数（只有一个元素的数组）
    * 合：把两个数**合并为有序数组**，再对有序数组进行合并，直到全部子数组合并为一个完整数组
      * 合并有序数组
        1. 新建一个空数组res，用于存放最终排序后的数组
        2. 比较两个有序数组的头部，较小者出队并推入res中
        3. 如果两个数组还有值，就重复第二步

* 快速排序

  * 谷歌浏览器的排序算法——快速排序
  * 时间复杂度——`O(nlogn)`
  * 思路：
    * 分区：从数组中任意选择一个“基准”，所有比基准小的元素放在基准前面，比基准大的元素放在基准的后面
    * 递归：递归地对基准前后的子数组进行分区

* 顺序搜索

  * 按照顺序搜索并判断数组中是否包含目标值

* 二分搜索

  * 数组必须为**有序数组**
  * 从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束
  * 如果目标值大于或小于中间，则在大于或小于中间元素的那一半数组中搜索

  ![image-20240630181519149](C:\Users\ccwangxin\AppData\Roaming\Typora\typora-user-images\image-20240630181519149.png)

##### 算法设计思想

* 分而治之
  * 分而治之是算法设计中的一种方法
    * 将一个问题分成多个和原问题**相似的独立的**小问题
    * 递归解决小问题
    * 将结果合并以解决原来的问题
  * 应用场景
    * 归并排序
    * 快速排序
* 动态规划
  * 动态规划是算法设计中的一种方法
  * 它将一个问题分解为**相互重叠**的子问题，通过反复求解子问题，来解决原来的问题
* 贪心
  * 贪心算法是算法设计中的一种方法
  * 期盼通过每个阶段的局部最优选择，从而达到全局最优
  * 结果并不一定最优
* 回溯
  * 回溯算法是算法设计中的一种方法
  * 回溯算法是一种渐进式寻找并构建问题解决方法的策略
  * 回溯算法会先从一个可能的动作开始解决问题，如果不行就回溯并选择另一个动作，直到问题解决

