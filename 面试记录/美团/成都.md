* 如何学习前端知识
* 项目中的难点如何解决的
* 解决过程中没用过的知识，如何做到熟练应用
* 当时采用的瀑布流的解决方案是最优解吗，还有没有更好的解决方案，其他人有没有采用过不同方案？
* let、const、var 区别
  * 在ES5中顶层对象的属性与全局变量是一致的，用`var`声明的变量既是全局变量也是顶层变量
  * **变量提升**
    * 用`var`声明的变量存在变量提升，当未声明时使用变量值为`undefined`
    * 用`let`和`const`声明的变量不存在变量提升，必须在声明之后使用，否则报错
  * **块级作用域**
    * 用`let`和`const`声明的变量具有块级作用域
  * **暂时性死区**
    * `var`不存在暂时性死区
    * `let`和`const`存在暂时性死区，只有变量被声明之后才能被使用
  * **重复声明**
    * 用`var`可以重复声明变量，后一个变量覆盖前一个变量
    * `let`和`const`不能重复声明变量，否则报错
  * **修改声明的变量**
    * `let`和`var`声明的变量可以被修改
    * `const`声明一个只读的常量，一旦被声明不可被修改
* `async`和`defer`区别
  * 两者都是异步加载`js`代码的方式
  * 前者异步加载完代码之后立即执行，因此在执行过程中依然有可能阻塞`dom`解析
  * 后者异步加载完jS代码之后等待`dom`解析完成后执行js代码，不会阻塞`dom`解析
* 对`Promise`的理解
  * `promise`是`ES6`处理异步事件的解决方案，解决了回调地狱的问题
  * `promise`有三个状态：`pending`、`fulfilled`和`rejected`，且状态改变是不可逆的
  * `promise`可以控制回调函数执行的时机
  * `Promise.then()`方法中可以传入两个回调函数，成功的回调和失败的回调，并且`.then()`方法返回的也是一个`promise`对象
  * `promise`的实例方法有：`then`、`catch`和`finally`
  * `Primise`的静态方法有：`all`、`race`、`allSettled`、`resolve`、`reject`、`any`
* 对js事件循环的理解
  * `event loop`用于处理JS同步和异步代码的执行顺序，是JS运行机制的核心部分，以宏任务为基本单位
  * 当执行脚本时，遇到同步代码直接执行，遇到异步代码如果是宏任务就放入消息队列，如果是微任务就放入微任务队列
  * 当前同步代码执行完毕就去调用微任务队列中的代码继续执行，直到微任务队列为空，本轮事件循环结束
  * 开启下一轮事件循环，去消息队列中再取一个宏任务，直到消息队列为空，代码执行完毕
  * 微任务：`promise.then()`产生的异步任务、`MutationObserver`、`process.nextTick`方法中的回调函数
  * 宏任务：`script`、`Dom`操作、`UI`渲染、用户交互（点击、鼠标事件）、`setTimeout`、HTTP请求

* 项目中`webpack`打包流程
  * 初始化参数
    - 读取`webpack.config.js`中的配置信息以及命令行指定的配置信息并合并成一个`options`对象
    - 创建`complier`对象并传入`options`
    - 根据`options.plugins`中的插件注册到`complier`对象中
  * 编译构建和代码生成
    - 调用`complier.run()`方法开始编译
      - 触发`hooks.run()`钩子函数，通知相关插件开始编译
      - 创建`compilation`编译对象（进行模块打包-`build`和代码生成-`seal`）
      - 读取`entry`中指定的编译入口文件，并用`loader`来转换无法识别的内容
      - 开始编译，创建`module`对象，记录模块依赖的子模块和所属入口文件
      - 将文件的内容解析成AST，根据抽象语法树来收集依赖，并将`require`替换成`__webpack_require__`，并将AST转换成源代码
      - 如果存在依赖模块，则递归的构建依赖模块
      - 编译阶段完成，能够得到所有依赖模块`modules`
    - 代码生成
      - 编译结束后运行`seal()`生成`assets`产物
      - 根据`entry`创建对应的`chunk`并查找对应的`module`集合，`chunk`是`module`集合
      - 根据`chunk`生成assets
  * 输出文件
    - 将`assets`输出到`option.output`指定的文件路径中

* `webpack`如何识别依赖关系
  * 在解析当前模块内容时，遇到`require`或者`import`导入的模块时，会被认为是当前模块的依赖项，并递归解析依赖的所有模块，形成一个依赖关系图
  * 通过`compilation`对象的`build`方法进行模块的构建和依赖解析
  * 读取文件内容，对于无法识别的文件采用`loader`进行文件内容转换，每一个模块都是一个`module`对象
  * 如果遇到`require`或者`import`导入的内容先进行依赖存储
  * 然后遍历当前模块的依赖进行深度递归构建，从而形成一个依赖树

* `Common JS`与`ESM`区别
  * `CommonJS`是`nodejs`默认使用的模块格式，也适用于许多构建工具和打包器；使用`require()`进行导入，`module.export`或者`exports`进行导出；不适合用于浏览器环境，因为采用同步加载的方式可能会阻塞浏览器进程
  * `ESM`是现代JS标准中定义的模块格式，适用于浏览器和现代构建工具；使用`import`导入和`export`导出的方式，支持异步加载和按需加载，可以更好的利用浏览器的并行能力。
  
* `webpack`支持什么方式导入导出
  * `CommonJS` 
  * `ESM`
  * `UMD`
  * `AMD`
* `Vue`相关
  * `Vue2`与`Vue3`主要区别
  * 为什么采用`proxy`监听响应性
  * `watch`内部如何实现
  * `diff`实现
    * `diff`是一种在比较同层树节点的高效算法，在同层节点之间进行比较不会跨层比较
    * 通过`diff`算法比较得到虚拟节点的变化然后将此变化应用到真实dom渲染过程，从而减少dom操作，提高渲染性能
    * 在同层节点比较过程中从两端进行新旧虚拟节点的比较，如果遇到可复用的节点则直接复用
    * 然后递归的去比较深层节点是否相同
  * `data`为什么用函数的形式返回
    * 每次复用组件都会产生一次新的数据，为每个组件实例创建一个独立的数据空间
    * 如果返回一个对象则所有组件实例共用一份对象，导致一个组件更改数据其他组件的数据也会被更改
  * 跨域
  * TCP三次握手
    * 第一次握手，客户端向服务器发送一个SYN报文
    * 第二次握手，服务端接收到SYN报文后，向客户端发送SYN+ACK报文
    * 第三次握手，客户端确认到服务器发来的报文后，回应ACK报文进行确认
    * 好处
      * 确认双方的接收能力
      * 指定自己的初始化序列号，为之后的可靠传输做准备
      * 完成数字证书的认证和密钥协商
  * 服务端主动发送数据给客户端
    * 轮询
      * 客户端定时向服务器发送请求并等待响应——产生多余的请求，浪费资源和带宽
    * `websocket`
      * 客户端与服务端建立双向连接，全双工通讯
      * 基于TCP协议与HTTP协议也具有良好的兼容性，默认端口为80和443
      * 没有同源限制，客户端和服务器可以任意发送消息
      * 可以传输文本也可以发送二进制数据
    * `SSE`协议
      * `server-send Events`——服务器主动向浏览器以流的形式发送消息，本质上是一次下载
      * 使用`HTTP`协议，支持断线重连
      * 只能传送文本和流信息，支持自定义发送的消息类型
      * 支持跨域
      * `content-type: text/event-stream`
  
* 封装多个表单模块，统一处理
* 基于`Render`函数实现动态渲染
  * 调研其他实现方式
  * 为什么采用动态渲染方式