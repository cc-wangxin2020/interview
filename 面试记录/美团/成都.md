* 如何学习前端知识
* 项目中的难点如何解决的
* 解决过程中没用过的知识，如何做到熟练应用
* 当时采用的瀑布流的解决方案是最优解吗，还有没有更好的解决方案，其他人有没有采用过不同方案？
* let、const、var 区别
  * 在ES5中顶层对象的属性与全局变量是一致的，用`var`声明的变量既是全局变量也是顶层变量
  * **变量提升**
    * 用`var`声明的变量存在变量提升，当未声明时使用变量值为`undefined`
    * 用`let`和`const`声明的变量不存在变量提升，必须在声明之后使用，否则报错
  * **块级作用域**
    * 用`let`和`const`声明的变量具有块级作用域
  * **暂时性死区**
    * `var`不存在暂时性死区
    * `let`和`const`存在暂时性死区，只有变量被声明之后才能被使用
  * **重复声明**
    * 用`var`可以重复声明变量，后一个变量覆盖前一个变量
    * `let`和`const`不能重复声明变量，否则报错
  * **修改声明的变量**
    * `let`和`var`声明的变量可以被修改
    * `const`声明一个只读的常量，一旦被声明不可被修改
* `async`和`defer`区别
  * 两者都是异步加载`js`代码的方式
  * 前者异步加载完代码之后立即执行，因此在执行过程中依然有可能阻塞`dom`解析
  * 后者异步加载完jS代码之后等待`dom`解析完成后执行js代码，不会阻塞`dom`解析
* 对`Promise`的理解
  * `promise`是`ES6`处理异步事件的解决方案，解决了回调地狱的问题
  * `promise`有三个状态：`pending`、`fulfilled`和`rejected`，且状态改变是不可逆的
  * `promise`可以控制回调函数执行的时机
  * `Promise.then()`方法中可以传入两个回调函数，成功的回调和失败的回调，并且`.then()`方法返回的也是一个`promise`对象
  * `promise`的实例方法有：`then`、`catch`和`finally`
  * `Primise`的静态方法有：`all`、`race`、`allSettled`、`resolve`、`reject`、`any`
* 对js事件循环的理解
  * `event loop`用于处理JS同步和异步代码的执行顺序，是JS运行机制的核心部分，以宏任务为基本单位
  * 当执行脚本时，遇到同步代码直接执行，遇到异步代码如果是宏任务就放入消息队列，如果是微任务就放入微任务队列
  * 当前同步代码执行完毕就去调用微任务队列中的代码继续执行，直到微任务队列为空，本轮事件循环结束
  * 开启下一轮事件循环，去消息队列中再取一个宏任务，直到消息队列为空，代码执行完毕
  * 微任务：`promise.then()`产生的异步任务、`MutationObserver`、`process.nextTick`方法中的回调函数
  * 宏任务：`script`、`Dom`操作、`UI`渲染、用户交互（点击、鼠标事件）、`setTimeout`、HTTP请求
* 项目中`webpack`打包流程
  
* `webpack`如何识别依赖关系
* `Common JS`与`ESM`区别
* `webpack`支持什么方式导入导出
* `Vue`相关
  * `Vue2`与`Vue3`主要区别
  * 为什么采用`proxy`监听响应性
  * `watch`内部如何实现
  * `diff`实现
  * `data`为什么用函数的形式返回
  * 跨域
  * TCP三次握手
  * 服务端主动发送数据给客户端
    * 轮询
      * 客户端定时向服务器发送请求并等待响应——产生多余的请求，浪费资源和带宽
    * `websocket`
      * 客户端与服务端建立双向连接，全双工通讯
      * 基于TCP协议与HTTP协议也具有良好的兼容性，默认端口为80和443
      * 没有同源限制，客户端和服务器可以任意发送消息
      * 可以传输文本也可以发送二进制数据
    * `SSE`协议
      * `server-send Events`——服务器主动向浏览器以流的形式发送消息，本质上是一次下载
      * 使用`HTTP`协议，支持断线重连
      * 只能传送文本和流信息，支持自定义发送的消息类型
      * 支持跨域
      * `content-type: text/event-stream`
* 封装多个表单模块，统一处理
* 基于`Render`函数实现动态渲染
  * 调研其他实现方式
  * 为什么采用动态渲染方式